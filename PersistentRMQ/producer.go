package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/streadway/amqp"
)

/*
 * Helper function for checking value of each amqp call
 * Panic is a go builtin function that stops ordinary flow of control and begins panicking.
 * When a function F calls panic, the execution of F stops, anything with 'defer' gets executed normally and then F returns to the caller
 * the process continues up the stack until all functions in the current goroutine have returned, after which the program crashes.
 * Panics can be initiated directly or by runtime errors, such as out-of-bounds array context.
 * Please keep in mind that if you come from spanish countries you should use hisPanic
 */
func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("s%: %s", msg, err)
		panic(fmt.Sprintf("s%: %s", msg, err))
	}
}

func main() {
	/*
	 * Below, we are using amqp.Dial which abstracts a connection towards our RMQ server.
	 * This worries about authentication and procotol negotiation for us.
	 * Please not that we are using 'defer' which worries about closing this connection after it has been used.
	 * Defer is go builtin which is commonly used to simplify functions that perform clean-up actions.
	 * It allows us to think about closing each file fight after opening it, guaranteeing that,
	 * regardless of the number of return statements in the function, the files will be closed.
	 * Deferred calls will get executed LIFO manner.
	 */
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	/*
	 * Queue declare will declare a queue for us, this operation is idempotent and will only create a queue if it doesn't exist already.
	 * Parameters for this function call are:
	 * - String value which holds the name of the queue, in case of an empty string the value is autogenerated for us,
	 * - boolean value of whether this queue will persist after the execution of RMQ server stops,
	 * - boolean value on whether declared queue will be deleted after all consumers disconnect from it,
	 * - exclusive flag which tells the queue it can only be used by the connection that created it, after the connection is closed the queue is deleted,
	 * - no-wait flag which tells the client to skip waiting for a reply method,
	 * - BasicProperties which give aditional functionality
	 */
	q, err := ch.QueueDeclare(
		"task_queue", // name
		true,         // durable
		false,        // delete when unused
		false,        // exclusive
		false,        // no-wait
		nil,          // arguments
	)
	failOnError(err, "Failed to declare a queue")

	/*
	 * Channel.Publish is a method used to publish a byte message towards our RMQ server.
	 * Following the RMQ flow, this message will get published to an exchange and aftewards passed into a correct Queue.
	 * Parameters are as follows, exchange, routing key, mandadory, immediate and content. More on this in PubSubRMQ/Publisher.
	 * What is important here is DeliveryMode: amqp.Peristent parameter in our content argument,
	 * this tells the RMQ server to keep the passed message even if it gets shutdown.
	 */
	body := bodyFrom(os.Args)
	err = ch.Publish(
		"",     // Exchange
		q.Name, // Routing key
		false,  // mandatory
		false,  // immediate
		amqp.Publishing{
			DeliveryMode: amqp.Persistent,
			ContentType:  "text/plain",
			Body:         []byte(body),
		})
	failOnError(err, "Failed to publish a message")
	log.Printf(" [x] Sent %s", body)
}

func bodyFrom(args []string) string {
	var s string
	if (len(args) < 2) || os.Args[1] == "" {
		s = "hello"
	} else {
		s = strings.Join(args[1:], " ")
	}
	return s
}
